local function LoadModule(url)
    local module
    repeat
        local success, result = pcall(function()
            return loadstring(game:HttpGet(url))()
        end)
        if success then
            module = result
        else
            warn("Module non charg√©, retry dans 1s : "..url)
            wait(1)
        end
    until module
    return module
end

local player = game.Players.LocalPlayer
repeat wait() until player and player.Character and player.Character:FindFirstChild("HumanoidRootPart")
--
if getgenv().ReinjectLoaded then return end
getgenv().ReinjectLoaded = true

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local ScriptURL = "https://raw.githubusercontent.com/Omeghub/devOnly/refs/heads/main/escapebrainrotdev"

local queue = queue_on_teleport 
           or (syn and syn.queue_on_teleport) 
           or (fluxus and fluxus.queue_on_teleport) 
           or queueonteleport

if not queue then
    return
end

local TeleportQueued = false

LocalPlayer.OnTeleport:Connect(function()
    if TeleportQueued then return end
    TeleportQueued = true

    queue([[
        repeat task.wait() until game:IsLoaded()
        task.wait(2)
        loadstring(game:HttpGet("]]..ScriptURL..[[", true))()
    ]])
end)
-- =========================================================
-- CHARGEMENT DE FLUENT ET INTERFACE
-- =========================================================
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/ImBrokz89/test/main/addons"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/ImBrokz89/test/main/Maddons"))()

local Window = Fluent:CreateWindow({
   Title = "Escape Tsunami For Brainrots I Omega Hub",
   TabWidth = 160,
   Size = UDim2.fromOffset(580, 460),
   Theme = "Dark",
   Acrylic = false,
   MinimizeKey = Enum.KeyCode.End 
})

local Tabs = {
    Farm = Window:AddTab({ Title = "Farm", Icon = "sword" }),
    Players = Window:AddTab({Title = "Player", Icon = "layers" }),
    Grab = Window:AddTab({ Title = "Grab", Icon = "flame" }),
    Events = Window:AddTab({ Title = "Event-Admin Abuse", Icon = "flame" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}
-- =========================================================
-- SERVICES
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

local LocalPlayer = Players.LocalPlayer
local UserId = LocalPlayer.UserId

local BrainrotsFolder = Workspace:WaitForChild("ActiveBrainrots")
local BasesFolder = Workspace:WaitForChild("Bases_NEW")
local TsunamisFolder = Workspace:WaitForChild("ActiveTsunamis")

-- =========================================================
-- DEBUG
local DEBUG = true
local function dprint(...)
    if DEBUG then
        print("[DEBUG]", ...)
    end
end

-- =========================================================
-- HTTP EXECUTOR CHECK
local HttpRequest =
    (syn and syn.request)
    or (http and http.request)
    or http_request
    or request
    or (fluxus and fluxus.request)

if not HttpRequest then
    error("‚ùå Executor incompatible (HTTP requis)")
end

-- =========================================================
-- WEBHOOK
local WebhookFile = "BrainrotWebhook.txt"
local DiscordIdFile = "BrainrotDiscordID.txt"

local WebhookUrl = ""
local DiscordID = ""

pcall(function() WebhookUrl = readfile(WebhookFile) end)
pcall(function() DiscordID = readfile(DiscordIdFile) end)

local RareMutations = { Diamond = true, Electric = true }
local WebhookEnabled = true

local function sendWebhook(data, reason)
    if not WebhookEnabled or WebhookUrl == "" then return end

    task.spawn(function() -- üîí isolation anti-crash
        local success, err = pcall(function()
            HttpRequest({
                Url = WebhookUrl,
                Method = "POST",
                Headers = { ["Content-Type"] = "application/json" },
                Body = HttpService:JSONEncode({
                    content = "",
                    username = "Brainrot Logger",
                    embeds = {{
                        title = reason == "SPAWN" and "üß† Brainrot Spawned" or "üéØ Brainrot Grabbed",
                        color = reason == "SPAWN" and 16753920 or 5793266,
                        fields = {
                            { name = "Name", value = data.Name },
                            { name = "Mutation", value = data.Mutation },
                            { name = "Class", value = data.Class },
                            { name = "Rate", value = data.Rate }
                        }
                    }}
                })
            })
        end)

        if not success then
            dprint("‚ö†Ô∏è Webhook ignor√© :", err)
        end
    end)
end

-- =========================================================
-- VARIABLES
local AutoGrab = false
local Processing = {}
local Connections = {}
local SlideConnection = nil
local OverrideWaveCheck = false
local SAFE_ZONE_LOCK_RADIUS = 6
local IN_SAFE_ZONE = false
local CURRENT_SAFE_ZONE = nil
local RUN_ID = 0
local IS_GRABBING = false
local GRAB_HOLD_TIME = 0.6


local LastWaveEscape = 0
local WAVE_ESCAPE_COOLDOWN = 0
local EMERGENCY_DISTANCE = 270
local SAFE_ANCHOR = false

-- =========================================================
-- SAFE ZONES
local SafeZones = {
    Vector3.new(201.137, -2.820, -9.582),
    Vector3.new(281.290, -2.820, -2.088),
    Vector3.new(396.021, -2.820, 4.207),
    Vector3.new(198.044, -2.820, 5.441),
    Vector3.new(287.627, -2.820, 4.897),
    Vector3.new(401.417, -2.820, 5.993),
    Vector3.new(542.917, -2.820, -17.325),
    Vector3.new(758.979, -2.820, -2.292),
    Vector3.new(1077.535, -2.820, 4.278),
    Vector3.new(1556.841, -2.820, -5.601),
    Vector3.new(2243.831, -2.820, 2.841),
    Vector3.new(2632.953, -2.820, -62.903)
}

-- =========================================================
-- BRAINROTS
local AllBrainrots = {
    "Alessio",
    "Esok Sekolah",
    "Diamantusa",
    "Bulbito Bandito Traktorito",
    "Burgerini Bearini",
    "Strawberry Elephant"
}

local SelectedBrainrots = {}

-- =========================================================
-- UTILS
local function getChar() return LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait() end
local function getHRP() return getChar():WaitForChild("HumanoidRootPart") end
local function getHumanoid() return getChar():WaitForChild("Humanoid") end
local function getSpeed() return LocalPlayer:GetAttribute("CurrentSpeed") or 120 end

local function disableCollision()
    for _, v in ipairs(getChar():GetDescendants()) do
        if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" then
            v.CanCollide = false
        end
    end
end

-- =========================================================
-- GET MY BASE (Bases_NEW compatible)

local function getMyBase()
    local bases = Workspace:WaitForChild("Bases_NEW")

    for _, base in ipairs(bases:GetChildren()) do
        if base:IsA("Model") then
            local holder = base:GetAttribute("Holder")
            if holder == UserId then
                dprint("üè† Base trouv√©e :", base.Name)
                return base
            end
        end
    end

    dprint("‚ùå Aucune base trouv√©e pour l'ID :", UserId)
    return nil
end


local function getModelPosition(model)
    if model.PrimaryPart then return model.PrimaryPart.Position end
    return model:GetPivot().Position
end

local function getPrompt(model)
    for _, v in ipairs(model:GetDescendants()) do
        if v:IsA("ProximityPrompt") and v.Enabled then
            return v
        end
    end
end

local function getBrainrotStats(model)
    local h = model:FindFirstChild("Handle")
    local gui = h and h:FindFirstChild("StatsGui")
    local frame = gui and gui:FindFirstChild("Frame")
    if not frame then return nil end

    return {
        Name = frame.BrainrotName.Text,
        Mutation = frame.Mutation.Visible and frame.Mutation.Text or "None",
        Class = frame.Class.Text,
        Rate = frame.Rate.Text
    }
end

local function getRealBrainrot(renderedModel)
    for _, child in ipairs(renderedModel:GetChildren()) do
        if child:IsA("Model") then
            return child
        end
    end
    return nil
end


-- =========================================================
-- SMART WAVE DETECTION (DEBUG)
local LastWaveDistances = {}

local function waveApproaching()
    local pos = getHRP().Position

    for _, wave in ipairs(TsunamisFolder:GetChildren()) do
        if wave:IsA("Model") and wave.PrimaryPart then
            local dist = (wave.PrimaryPart.Position - pos).Magnitude
            local last = LastWaveDistances[wave] or math.huge
            LastWaveDistances[wave] = dist

            if dist < 300 and dist < last then

                return true, dist
            end
        end
    end

    return false, math.huge
end

local function getClosestSafeZone()
    local hrpPos = getHRP().Position
    local best, dist = nil, math.huge

    for _, zone in ipairs(SafeZones) do
        local d = (zone - hrpPos).Magnitude
        if d < dist then
            best, dist = zone, d
        end
    end
    return best
end

local function getSafeZoneAwayFromWave()
    local hrp = getHRP()
    if not hrp then return nil end

    local hrpPos = hrp.Position
    local bestZone = nil
    local bestScore = -math.huge

    for _, wave in ipairs(TsunamisFolder:GetChildren()) do
        if wave:IsA("Model") and wave.PrimaryPart then
            local wavePos = wave.PrimaryPart.Position
            local waveForward = wave.PrimaryPart.CFrame.LookVector

            for _, zone in ipairs(SafeZones) do
                local vecFromWave = zone - wavePos
                local vecFromPlayer = zone - hrpPos

                local dist = vecFromPlayer.Magnitude
                if dist < 1 then continue end

                local dirFromWave = vecFromWave.Unit
                local dirFromPlayer = vecFromPlayer.Unit

                if waveForward:Dot(dirFromWave) <= 0 then
                    continue
                end

                -- ‚úÖ zone encore AVANT la wave
                local lateralScore =
                    math.abs(waveForward:Dot(dirFromPlayer)) * -500

                local score =
                    -dist
                    + lateralScore

                if score > bestScore then
                    bestScore = score
                    bestZone = zone
                end
            end
        end
    end

    return bestZone
end

local scanExisting
local connectAll
local disconnectAll
local slideTo
local forceSafeZone
local stopSlide

forceSafeZone = function()
    if IN_SAFE_ZONE then return end

    local safe = getSafeZoneAwayFromWave()
    if not safe then
    dprint("‚õî Aucune safe zone derri√®re ‚Üí attente passive")

    repeat
        task.wait(0.2)
    until not waveApproaching()

    OverrideWaveCheck = false
    IN_SAFE_ZONE = false
    CURRENT_SAFE_ZONE = nil

    dprint("‚úÖ Wave pass√©e ‚Üí reprise normale")
    return
    end

    dprint("üö® SAFE ZONE -> arri√®re uniquement")
    CURRENT_SAFE_ZONE = safe
    OverrideWaveCheck = true
    slideTo(safe, 0.1)

    repeat
        task.wait(0.1)
    until not getHRP() or (getHRP().Position - safe).Magnitude < 2

    stopSlide()
    IN_SAFE_ZONE = true

    repeat
        task.wait(0.1)
    until not waveApproaching()

    IN_SAFE_ZONE = false
    OverrideWaveCheck = false
    CURRENT_SAFE_ZONE = nil

    table.clear(Processing)
    scanExisting()

    dprint("‚úÖ Wave termin√©e ‚Üí reprise grab")
end

local function waveBlocksPath(targetPos)
    local hrp = getHRP()
    if not hrp then return false end

    local toTarget = (targetPos - hrp.Position).Unit

    for _, wave in ipairs(TsunamisFolder:GetChildren()) do
        if wave:IsA("Model") and wave.PrimaryPart then
            local wavePos = wave.PrimaryPart.Position
            local waveDir = wave.PrimaryPart.CFrame.LookVector

            local waveToPlayer = (hrp.Position - wavePos).Unit

            -- wave qui vient vers moi
            if waveDir:Dot(waveToPlayer) > 0.6 then
                -- et qui bloque ma direction
                if waveDir:Dot(toTarget) < -0.3 then
                    dprint("üö´ Wave bloque le chemin vers la base")
                    return true
                end
            end
        end
    end

    return false
end

local function slideToBaseSafely()
    local base = getMyBase()
    if not base or not base.PrimaryPart then
        dprint("‚ùå Base introuvable")
        return
    end

    local basePos = base.PrimaryPart.Position

    -- double check AVANT de partir
    if waveBlocksPath(basePos) then
        dprint("‚ö†Ô∏è Retour base bloqu√© ‚Üí SAFE ZONE")
        forceSafeZone()
        return
    end

    dprint("üè† Slide SAFE vers la base")
    slideTo(basePos, 3)
end

local function grabPromptSafe(prompt)
    if not prompt then return false end
    if IS_GRABBING then return false end

    IS_GRABBING = true

    stopSlide()

    local hrp = getHRP()
    local hum = getHumanoid()

    hum:ChangeState(Enum.HumanoidStateType.Physics)
    hrp.AssemblyLinearVelocity = Vector3.zero
    hrp.AssemblyAngularVelocity = Vector3.zero

    -- HOLD r√©el du prompt
    prompt:InputHoldBegin()
    task.wait(prompt.HoldDuration > 0 and prompt.HoldDuration or GRAB_HOLD_TIME)
    prompt:InputHoldEnd()

    task.wait(0.05)

    hum:ChangeState(Enum.HumanoidStateType.Running)
    IS_GRABBING = false

    return true
end

-- =========================================================
-- SLIDE ENGINE
stopSlide = function()
    if SlideConnection then
        SlideConnection:Disconnect()
        SlideConnection = nil
        dprint("Slide STOP")
    end

    local hrp = getHRP()
    local hum = getHumanoid()

    for _, v in ipairs(hrp:GetChildren()) do
        if v:IsA("BodyVelocity") or v:IsA("BodyGyro") then
            v:Destroy()
        end
    end

    hum.PlatformStand = false
    hum:ChangeState(Enum.HumanoidStateType.Running)
    hrp.AssemblyLinearVelocity = Vector3.zero
    hrp.AssemblyAngularVelocity = Vector3.zero
end

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)

    RUN_ID += 1

    IN_SAFE_ZONE = false
    OverrideWaveCheck = false
    CURRENT_SAFE_ZONE = nil
    -- reset lucky
    ProcessingLucky = {}

    table.clear(Processing)
    stopSlide()

    dprint("‚ôªÔ∏è Reset apr√®s mort | RUN_ID =", RUN_ID)

if AutoGrab then
    task.delay(0, function()
        scanExisting()
    end)
end

end)


slideTo = function(position, stopDist)
    if not position then
        dprint("‚õî slideTo annul√© : position nil")
        return
    end

    dprint("slideTo appel√©")
    stopDist = stopDist or 0.5
    stopSlide()

    local hrp = getHRP()
    local hum = getHumanoid()

    hum.PlatformStand = true
    disableCollision()

    local bv = Instance.new("BodyVelocity", hrp)
    bv.MaxForce = Vector3.new(1e9, 1e9, 1e9)

    local bg = Instance.new("BodyGyro", hrp)
    bg.MaxTorque = Vector3.new(1e9, 1e9, 1e9)

    SlideConnection = RunService.Heartbeat:Connect(function()

        if SAFE_ANCHOR then
            dprint("Slide bloqu√© (SAFE_ANCHOR)")
            return
        end

local approaching, dist = waveApproaching()
if approaching and not OverrideWaveCheck and dist <= EMERGENCY_DISTANCE then
    dprint("üö® Wave dangereuse ‚Üí safe zone")
    stopSlide()
    forceSafeZone()
    return
end



        local dir = position - hrp.Position
        local dist2 = dir.Magnitude

if dist2 < stopDist then
    dprint("Slide arriv√©")
    stopSlide()
    return
end

        bg.CFrame = CFrame.lookAt(hrp.Position, hrp.Position + dir)
        bv.Velocity = dir.Unit * getSpeed()
    end)
end

-- =========================================================
-- MAIN LOGIC
local function handleBrainrot(model)
    if not AutoGrab then return end
    if Processing[model] then return end
    if not SelectedBrainrots[model.Name] then return end

    Processing[model] = true
    local myRun = RUN_ID

    while AutoGrab and model.Parent and myRun == RUN_ID do

        -- s√©curit√© run
        if myRun ~= RUN_ID then
            break
        end

        -- si grab en cours, on attend
        if IS_GRABBING then
            task.wait(0.05)
            continue
        end

        -- si en safe zone, on attend la fin compl√®te
        if IN_SAFE_ZONE then
            task.wait(0.1)
            continue
        end

        -- d√©tection wave
        local approaching, dist = waveApproaching()
        if approaching and dist <= EMERGENCY_DISTANCE then
            forceSafeZone()
            task.wait(0.2)
            continue
        end

        -- position du brainrot
        local pos = getModelPosition(model)
        if not pos then
            break
        end

        -- slide vers le brainrot
        slideTo(pos, 2)

        -- attente d‚Äôarriv√©e ou interruption
        repeat
            task.wait(0.05)
            if myRun ~= RUN_ID then break end
            if IN_SAFE_ZONE then break end
            if IS_GRABBING then break end
        until not model.Parent
           or (getHRP().Position - pos).Magnitude < 4

        -- re-check s√©curit√©
        if myRun ~= RUN_ID or IN_SAFE_ZONE or not model.Parent then
            continue
        end

        -- grab s√©curis√©
        local prompt = getPrompt(model)
        if prompt then
            if grabPromptSafe(prompt) then
                break
            end
        end

        task.wait(0.1)
    end

    -- cleanup si run invalide
    if myRun ~= RUN_ID then
        Processing[model] = nil
        return
    end

    -- retour √† la base apr√®s grab
    local base = getMyBase()
    if base and base.PrimaryPart then
        dprint("üè† Retour √† la base")
        slideToBaseSafely()
    end

    Processing[model] = nil
end

-- =========================================================
-- CONNECTIONS
scanExisting = function()
    for _, folder in ipairs(BrainrotsFolder:GetChildren()) do
        if folder:IsA("Folder") then
            for _, model in ipairs(folder:GetChildren()) do
                if model:IsA("Model") then

                    if SelectedBrainrots[model.Name] and not Processing[model] then
                        local real = getRealBrainrot(model)
                        if real then
                            task.spawn(handleBrainrot, real)
                        end
                    end
                end
            end
        end
    end
end

connectAll = function()
    disconnectAll() -- üî• indispensable
    dprint("üîå connectAll")
    for _, folder in ipairs(BrainrotsFolder:GetChildren()) do
        if folder:IsA("Folder") then
        local conn = folder.ChildAdded:Connect(function(model)
        if not model:IsA("Model") then return end

            local real = getRealBrainrot(model)
            if real and SelectedBrainrots[real.Name] then
            dprint("üÜï Brainrot d√©tect√© :", real.Name)
             handleBrainrot(real)
            end
        end)
            table.insert(Connections, conn)
        end
    end
end

disconnectAll = function()
    dprint("disconnectAll appel√©")

    RUN_ID += 1

    for _, c in ipairs(Connections) do
        if c then
            c:Disconnect()
        end
    end
    table.clear(Connections)
    stopSlide()
end


-- =========================================================
-- UI
Tabs.Grab:AddSection("Brainrot Selector")

Tabs.Grab:AddDropdown("BrainrotSelector", {
    Title = "Select Brainrots",
    Values = AllBrainrots,
    Multi = true,
    Default = {},
    Callback = function(values)
        table.clear(SelectedBrainrots)
        for name, enabled in pairs(values) do
            if enabled then SelectedBrainrots[name] = true end
        end
    end
})

Tabs.Grab:AddToggle("AutoGrab", {
    Title = "Auto Grab Brainrot (Slide + Safe)",
    Default = false,
    Callback = function(v)
        AutoGrab = v
        if v then
            scanExisting()
            connectAll()
        else
            disconnectAll()
        end
    end
})

Tabs.Grab:AddSection("Webhook Settings")

Tabs.Grab:AddInput("WebhookInput", {
    Title = "Discord Webhook",
    Default = WebhookUrl,
    Callback = function(url)
        WebhookUrl = url
        writefile(WebhookFile, url)
    end
})

Tabs.Grab:AddInput("DiscordIDInput", {
    Title = "Discord ID (mention)",
    Default = DiscordID,
    Callback = function(id)
        DiscordID = id
        writefile(DiscordIdFile, id)
    end
})
-- =========================================================
-- AUTO LUCKY BLOCK

local LuckyBlocksFolder = Workspace:WaitForChild("GlobalLuckyBlocks")

local AutoLucky = false
local ProcessingLucky = {}
local LuckyConnections = {}

local function isLuckyBlock(model)
    return model:IsA("Model")
       and model.Name:sub(1, 16) == "GlobalLuckyBlock_"
end

local function getLuckyPrompt(model)
    for _, v in ipairs(model:GetDescendants()) do
        if v:IsA("ProximityPrompt") and v.Enabled then
            return v
        end
    end
end

local function handleLuckyBlock(model)
    if not AutoLucky then return end
    if ProcessingLucky[model] then return end
    if not isLuckyBlock(model) then return end

    ProcessingLucky[model] = true
    local myRun = RUN_ID

    dprint("üçÄ Lucky Block cibl√© :", model.Name)

    while AutoLucky and model.Parent and myRun == RUN_ID do

        if myRun ~= RUN_ID then break end

        if IS_GRABBING or IN_SAFE_ZONE then
            task.wait(0.1)
            continue
        end

        -- wave check
        local approaching, dist = waveApproaching()
        if approaching and dist <= EMERGENCY_DISTANCE then
            dprint("üåä Wave pendant Lucky ‚Üí SafeZone")
            forceSafeZone()
            task.wait(0.2)
            continue
        end

        local pos = getModelPosition(model)
        if not pos then break end

        slideTo(pos, 2)

        repeat
            task.wait(0.05)
            if myRun ~= RUN_ID then break end
            if IN_SAFE_ZONE then break end
        until not model.Parent
           or (getHRP().Position - pos).Magnitude < 5

        if not model.Parent or IN_SAFE_ZONE then
            continue
        end

        local prompt = getLuckyPrompt(model)
        if prompt then
            grabPromptSafe(prompt)
            break
        end
    end

    ProcessingLucky[model] = nil
end

local function scanLuckyBlocks()
    if not AutoLucky then return end

    for _, model in ipairs(LuckyBlocksFolder:GetChildren()) do
        if isLuckyBlock(model) and not ProcessingLucky[model] then
            task.spawn(handleLuckyBlock, model)
        end
    end
end

local function connectLucky()
    for _, c in ipairs(LuckyConnections) do
        c:Disconnect()
    end
    table.clear(LuckyConnections)

    local conn = LuckyBlocksFolder.ChildAdded:Connect(function(model)
        if AutoLucky and isLuckyBlock(model) then
            dprint("üÜï Lucky Block d√©tect√© :", model.Name)
            handleLuckyBlock(model)
        end
    end)

    table.insert(LuckyConnections, conn)
end

Tabs.Events:AddToggle("AutoLucky", {
    Title = "Auto Lucky Blocks",
    Default = false,
    Callback = function(v)
        AutoLucky = v

        if v then
            dprint("‚úÖ Auto Lucky ON")
            connectLucky()
            scanLuckyBlocks()
        else
            dprint("‚õî Auto Lucky OFF")
            ProcessingLucky = {}
        end
    end
})
-- =========================================================
-- AUTO TP OBBY END (RADIOACTIVE) + AUTO JOIN GAME

-- SERVICES
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local TeleportService = game:GetService("TeleportService")

-- PLAYER
local LocalPlayer = Players.LocalPlayer

-- CONFIG
local TARGET_GAME_ID = 131623223084840
local MapVariants = Workspace:WaitForChild("MapVariants")

-- STATES
local AutoObbyTP = false
local RadioactiveConn = nil
local HasTeleported = false

-- =========================================================
-- UTIL

local function getHRP()
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    return char:WaitForChild("HumanoidRootPart")
end

-- =========================================================
-- AUTO JOIN AFTER TP

local function autoJoinAfterTP()
    if HasTeleported then return end
    HasTeleported = true

    task.spawn(function()
        print("[AUTO OBBY] Join game dans 2s")
        task.wait(2)

        if AutoObbyTP then
            print("[AUTO OBBY] T√©l√©portation vers le jeu cible")
            TeleportService:Teleport(TARGET_GAME_ID, LocalPlayer)
        end
    end)
end


-- =========================================================
-- TP OBBY END

local function teleportToObbyEnd(radioactive)
    if not radioactive then return end

    local obbyEnd = radioactive:FindFirstChild("ObbyEnd")
    if not obbyEnd then
        warn("[AUTO OBBY] ObbyEnd introuvable")
        return
    end

    local hrp = getHRP()

    if obbyEnd:IsA("Model") then
        if not obbyEnd.PrimaryPart then
            warn("[AUTO OBBY] ObbyEnd sans PrimaryPart")
            return
        end
        hrp.CFrame = obbyEnd.PrimaryPart.CFrame + Vector3.new(0, 5, 0)
    else
        hrp.CFrame = obbyEnd.CFrame + Vector3.new(0, 5, 0)
    end

    print("[AUTO OBBY] TP vers ObbyEnd")
    autoJoinAfterTP()
end

-- =========================================================
-- MAP HANDLER

local function handleRadioactive(model)
    if not AutoObbyTP then return end
    if model.Name ~= "Radioactive" then return end

    print("[AUTO OBBY] Radioactive d√©tect√©")

    task.spawn(function()
        for _ = 1, 100 do
            if not AutoObbyTP then return end
            if model:FindFirstChild("ObbyEnd") then
                teleportToObbyEnd(model)
                return
            end
            task.wait(0.1)
        end
        warn("[AUTO OBBY] Timeout ObbyEnd")
    end)
end

-- =========================================================
-- ENABLE / DISABLE

local function enableAutoObby()
    if RadioactiveConn then return end
    HasTeleported = false

    local existing = MapVariants:FindFirstChild("Radioactive")
    if existing then
        handleRadioactive(existing)
    end

    RadioactiveConn = MapVariants.ChildAdded:Connect(handleRadioactive)
end

local function disableAutoObby()
    if RadioactiveConn then
        RadioactiveConn:Disconnect()
        RadioactiveConn = nil
    end
    HasTeleported = false
end

-- =========================================================
-- UI

Tabs.Events:AddSection("Auto Farm Muta Radio")

Tabs.Events:AddToggle("AutoObbyTP", {
    Title = "Auto TP ObbyEnd (Radioactive)",
    Default = false,
    Callback = function(v)
        AutoObbyTP = v
        if v then
            print("[AUTO OBBY] ON")
            enableAutoObby()
        else
            print("[AUTO OBBY] OFF")
            disableAutoObby()
        end
    end
})

-- =========================================================
-- MANUAL JOIN BUTTON

Tabs.Events:AddButton({
    Title = "Join Game",
    Description = "Rejoint auto Game Farm Lucky Block",
    Callback = function()
        TeleportService:Teleport(TARGET_GAME_ID, LocalPlayer)
    end
})



-- =========================================================
-- AUTO COLLECT (BASES_NEW | 10 MIN COOLDOWN)

local Section = Tabs.Farm:AddSection("Collect")

local AutoCollect = false
local CollectCooldown = 600 -- 10 minutes
local LastCollectTime = 0

local BasesNewFolder = Workspace:WaitForChild("Bases_NEW")

-- =========================================================
-- GET MY BASE (Bases_NEW)

local function getMyBase()
    for _, base in ipairs(BasesNewFolder:GetChildren()) do
        if base:IsA("Model") then
            local holder = base:GetAttribute("Holder")
            if holder and tostring(holder) == tostring(UserId) then
                return base
            end
        end
    end
    return nil
end

-- =========================================================
-- AUTO COLLECT LOGIC

local function autoCollect()
    if not AutoCollect then return end
    if os.clock() - LastCollectTime < CollectCooldown then return end

    local base = getMyBase()
    if not base then
        dprint("‚ùå AutoCollect : base introuvable")
        return
    end

    local slots = base:FindFirstChild("Slots")
    if not slots then
        dprint("‚ùå AutoCollect : Slots introuvables")
        return
    end

    local hrp = getHRP()
    if not hrp then return end

    local collected = false

    for i = 1, 30 do
        local slot = slots:FindFirstChild("Slot" .. i)
        if slot and slot:IsA("Model") then
            local collectPart = slot:FindFirstChild("Collect")
            if collectPart then
                local gui = collectPart:FindFirstChildOfClass("SurfaceGui")
                if gui and gui.Enabled then
                    dprint("üí∞ Collect :", slot.Name)
                    hrp.CFrame = collectPart.CFrame + Vector3.new(0, 3, 0)
                    task.wait(0.35)
                    collected = true
                end
            end
        end
    end

    if collected then
        LastCollectTime = os.clock()
        dprint("‚úÖ Collect termin√© ‚Äì cooldown lanc√©")
    end
end


Tabs.Farm:AddToggle("AutoCollect", {
    Title = "Auto Collect (10 min)",
    Default = false,
    Callback = function(v)
        AutoCollect = v
        if v then
            dprint("‚úÖ AutoCollect ON")
            task.spawn(function()
                while AutoCollect do
                    autoCollect()
                    task.wait(1)
                end
            end)
        else
            dprint("‚õî AutoCollect OFF")
        end
    end
})


-- =========================================================
-- ANTI AFK (STABLE)
local Players = game:GetService("Players")
local VirtualUser = game:GetService("VirtualUser")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer

local AntiAFK = false
local AntiAFKConnection = nil
local LAST_ACTION = 0
local ACTION_DELAY = 600

local function startAntiAFK()
    if AntiAFKConnection then return end

    AntiAFKConnection = RunService.Heartbeat:Connect(function()
        if not AntiAFK then return end

        if os.clock() - LAST_ACTION >= ACTION_DELAY then
            LAST_ACTION = os.clock()

            local cam = workspace.CurrentCamera.CFrame
            local pos = Vector2.new(0, 0)

            VirtualUser:Button1Down(pos, cam)
            task.wait(0.05)
            VirtualUser:Button1Up(pos, cam)

            VirtualUser:MoveMouse(pos)

            print("[ANTI-AFK] Click souris envoy√©")
        end
    end)
end

local function stopAntiAFK()
    if AntiAFKConnection then
        AntiAFKConnection:Disconnect()
        AntiAFKConnection = nil
    end
end

Tabs.Players:AddToggle("AntiAFK", {
    Title = "Anti AFK",
    Default = false,
    Callback = function(v)
        AntiAFK = v
        if v then
            startAntiAFK()
        else
            stopAntiAFK()
        end
    end
})


-- =========================================================
-- CONFIGURATION SYSTEM
-- =========================================================
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)
SaveManager:LoadAutoloadConfig()
Window:SelectTab(1)

-- =========================
-- MOBILE / PC BUTTON

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "FluentMobileButton"
screenGui.Parent = playerGui
screenGui.ResetOnSpawn = false

local openButton = Instance.new("ImageButton")
openButton.Size = UDim2.new(0, 40, 0, 40)
openButton.Position = UDim2.new(0, 10, 0, 10)
openButton.BackgroundColor3 = Color3.fromRGB(0,0,0)
openButton.BackgroundTransparency = 0.5
openButton.Image = "rbxassetid://133520358863074"
openButton.ScaleType = Enum.ScaleType.Fit
openButton.BorderSizePixel = 0
openButton.Parent = screenGui
openButton.ZIndex = 10

local uicorner = Instance.new("UICorner")
uicorner.CornerRadius = UDim.new(0, 20)
uicorner.Parent = openButton

local dragging
local dragInput
local dragStart
local startPos

local function update(input)
    local delta = input.Position - dragStart
    openButton.Position = UDim2.new(
        startPos.X.Scale, startPos.X.Offset + delta.X,
        startPos.Y.Scale, startPos.Y.Offset + delta.Y
    )
end

openButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = openButton.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

openButton.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

game:GetService("UserInputService").InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        update(input)
    end
end)

openButton.MouseButton1Click:Connect(function()
    local VirtualInputManager = game:GetService("VirtualInputManager")
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.LeftControl, false, game)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.LeftControl, false, game)
end)

local function removeButton()
    if openButton and openButton.Parent then
        openButton:Destroy()
    end
end

if Window.UI and Window.UI.CloseButton then
    Window.UI.CloseButton.MouseButton1Click:Connect(function()
        removeButton()
    end)
else
    if Window.OnClose then
        local oldClose = Window.OnClose
        Window.OnClose = function()
            removeButton()
            if oldClose then oldClose() end
        end
    end
end
