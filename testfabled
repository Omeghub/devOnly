
local function LoadModule(url)
    local module
    repeat
        local success, result = pcall(function()
            return loadstring(game:HttpGet(url))()
        end)
        if success then
            module = result
        else
            warn("Module non charg√©, retry dans 1s : "..url)
            wait(1)
        end
    until module
    return module
end

local player = game.Players.LocalPlayer
repeat wait() until player and player.Character and player.Character:FindFirstChild("HumanoidRootPart")
--
if getgenv().ReinjectLoaded then return end
getgenv().ReinjectLoaded = true

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local ScriptURL = "https://raw.githubusercontent.com/Omeghub/devOnly/refs/heads/main/testfabled"

local queue = queue_on_teleport 
           or (syn and syn.queue_on_teleport) 
           or (fluxus and fluxus.queue_on_teleport) 
           or queueonteleport

if not queue then
    return
end

local TeleportQueued = false

LocalPlayer.OnTeleport:Connect(function()
    if TeleportQueued then return end
    TeleportQueued = true

    queue([[
        repeat task.wait() until game:IsLoaded()
        task.wait(2)
        loadstring(game:HttpGet("]]..ScriptURL..[[", true))()
    ]])
end)
--=======================================================
-- UI
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/Omeghub/OmegaHubtest/refs/heads/main/UiSave"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/Omeghub/OmegaHubtest/refs/heads/main/Interface"))()

local Window = Fluent:CreateWindow({
   Title = "OmegaHub | Fabled-Legacy",
   TabWidth = 160,
   Size = UDim2.fromOffset(580, 460),
   Theme = "Dark",
   Acrylic = false,
   MinimizeKey = Enum.KeyCode.End
})

local Tabs = {
    Main = Window:AddTab({ Title = "Auto Farm", Icon = "swords" }),
    Tower = Window:AddTab({ Title = "Infinite Towers", Icon = "sword" }),
    Stats = Window:AddTab({ Title = "Stats", Icon = "trending-up" }),
    Sell = Window:AddTab({Title = "Sell", Icon = "layers" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}
-- ========================================================
-- AUTO FARM SYSTEM

local AutoFarmValue = Instance.new("BoolValue")
AutoFarmValue.Value = false

local AutoSpellValue = Instance.new("BoolValue")
AutoSpellValue.Value = false

local AutoStartDungeon = false
local DungeonStarted = false
local executedDungeons = {}

-- ========================================================
-- DUNGEON SCRIPTS
local DungeonScripts = {
    ["Raided Village"] = "https://raw.githubusercontent.com/Omeghub/FabledlegacyDungeon/refs/heads/main/Afirstdungeon",
    ["Sunken Fortress"] = "https://raw.githubusercontent.com/Omeghub/FabledlegacyDungeon/refs/heads/main/Btwodungeon",
    ["Cursed Marshes"] = "https://raw.githubusercontent.com/Omeghub/FabledlegacyDungeon/refs/heads/main/Cthirddungeon",
    ["Ragnar√∂k's Descent"] = "https://raw.githubusercontent.com/Omeghub/FabledlegacyDungeon/refs/heads/main/Dfourdungeon",
    ["Thundering Peaks"] = "https://raw.githubusercontent.com/Omeghub/FabledlegacyDungeon/refs/heads/main/Efivedungeon",
    ["Fallen Paradise"] = "https://raw.githubusercontent.com/Omeghub/FabledlegacyDungeon/refs/heads/main/Fsixdungeon",
    ["Eternal Domain"] = "",
    ["Stardust Citadel"] = "",
    ["Ethereal Farlands"] = "",
    ["Hellbound Sanctum"] = "",
    ["Forsaken Limbo"] = "",
    ["Neon District"] = "",
}

-- ========================================================
-- SERVICES
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

-- ========================================================
-- RESTRICTED PLACE
local RESTRICTED_PLACE = 11872917490
local function IsRestrictedPlace()
    return game.PlaceId == RESTRICTED_PLACE
end

-- ========================================================
-- MAIN LOOP
task.spawn(function()
    while task.wait(1) do
        -- ========================
        -- DUNGEON LOADER
        local settings = Workspace:FindFirstChild("DungeonSettings")
        local session = settings and settings:FindFirstChild("SessionName")

        if session then
            local dungeonName = session.Value
            if not executedDungeons[dungeonName] then
                local url = DungeonScripts[dungeonName]
                if url and url ~= "" then
                    local success, err = pcall(function()
                        local dungeonFunction = loadstring(game:HttpGet(url))()
                        dungeonFunction(AutoFarmValue, AutoSpellValue)
                        executedDungeons[dungeonName] = true
                    end)
                    if not success then
                        warn("Erreur lors du chargement du dungeon " .. dungeonName .. ": " .. err)
                    end
                end
            end
        end

        -- ========================
        -- AUTO START DUNGEON
        if AutoStartDungeon and not DungeonStarted and not IsRestrictedPlace() then
            local gui = LocalPlayer:FindFirstChild("PlayerGui")
            local main = gui and gui:FindFirstChild("mainGui")
            local btn = main and main:FindFirstChild("startDungeon")

            if btn and btn:IsA("GuiObject") and btn.Visible then
                local equipBest = ReplicatedStorage:FindFirstChild("EquipBest")
                if equipBest then
                    equipBest:FireServer()
                end

                local startEvent = ReplicatedStorage:WaitForChild("StartDungeon")
                local args = {{true, "lol"}}
                startEvent:FireServer(unpack(args))

                DungeonStarted = true
            end
        end
    end
end)

Tabs.Main:AddToggle("AutoFarmTP", {
    Title = "Auto Farm TP",
    Default = false,
    Callback = function(v)
        AutoFarmValue.Value = v
        AutoStartDungeon = v
    end
})

Tabs.Main:AddToggle("AutoSpell", {
    Title = "Auto Spell Q/E/R",
    Default = false,
    Callback = function(v)
        AutoSpellValue.Value = v
    end
})

-- =========================================================
-- AUTO RETRY (FAIL + COMPLETION)
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

local AutoRetry = false
local Connections = {}

local function fireRetry(reason)
    if not AutoRetry then return end
    if _G.ForceReturnToLobby then return end

    local voteRemote = ReplicatedStorage:FindFirstChild("voteRemote")
    if voteRemote then
        warn("üîÅ Auto Retry triggered:", reason)
        voteRemote:FireServer("repeat")

        if _G.sendAlertWebhook then
            _G.sendAlertWebhook(
                "Auto Retry Dungeon Finish",
                reason
            )
        end
    end
end

local function SetupAutoRetry()
    -- √©viter double setup
    if #Connections > 0 then return end

    local gui = LocalPlayer:WaitForChild("PlayerGui")
    local completionScreen = gui:WaitForChild("CompletionScreen")

    local failedFrame = completionScreen:WaitForChild("failedFrame")
    local completionBorder = completionScreen:WaitForChild("CompletionBorder")

    -- ‚ùå DUNGEON FAILED
    table.insert(Connections,
        failedFrame:GetPropertyChangedSignal("Visible"):Connect(function()
            if failedFrame.Visible then
                fireRetry("Dungeon failed")
            end
        end)
    )

    -- ‚úÖ DUNGEON COMPLETED
    table.insert(Connections,
        completionBorder:GetPropertyChangedSignal("Visible"):Connect(function()
            if completionBorder.Visible then
                fireRetry("Dungeon completed")
            end
        end)
    )
end

local function StopAutoRetry()
    AutoRetry = false
    for _, c in ipairs(Connections) do
        pcall(function() c:Disconnect() end)
    end
    Connections = {}
end

Tabs.Main:AddToggle("AutoRetry", {
    Title = "Auto Retry (Fail + Win)",
    Default = false,
    Callback = function(v)
        AutoRetry = v
        if v then
            SetupAutoRetry()
        else
            StopAutoRetry()
        end
    end
})
-- =========================================================
-- AUTO SMART SWITCH DUNGEON

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer

local AutoSwitchDungeon = false
local LastSwitchSignature = ""

Tabs.Main:AddToggle("AutoSmartSwitch", {
    Title = "Auto Switch Dungeon (Smart)",
    Default = false,
    Callback = function(v)
        AutoSwitchDungeon = v
    end
})

local DungeonOrder = {
    "Raided Village",
    "Sunken Fortress",
    "Cursed Marshes",
    "Ragnar√∂k's Descent",
    "Thundering Peaks",
    "Fallen Paradise",
    "Eternal Domain",
    "Stardust Citadel",
    "Ethereal Farlands",
    "Hellbound Sanctum",
    "Forsaken Limbo",
    "Neon District"
}

local DungeonReqs = {
    ["Raided Village"]     = {Normal=1,   Expert=5,   Chaos=10,  Calamity=15},
    ["Sunken Fortress"]    = {Normal=20,  Expert=25,  Chaos=30,  Calamity=35},
    ["Cursed Marshes"]     = {Normal=40,  Expert=45,  Chaos=50,  Calamity=55},
    ["Ragnar√∂k's Descent"] = {Normal=60,  Expert=65,  Chaos=70,  Calamity=75},
    ["Thundering Peaks"]   = {Normal=80,  Expert=85,  Chaos=90,  Calamity=95},
    ["Fallen Paradise"]    = {Normal=100, Expert=105, Chaos=110, Calamity=115},
    ["Eternal Domain"]     = {Normal=120, Expert=125, Chaos=130, Calamity=135},
    ["Stardust Citadel"]   = {Normal=140, Expert=145, Chaos=150, Calamity=155},
    ["Ethereal Farlands"]  = {Normal=160, Expert=165, Chaos=170, Calamity=175},
    ["Hellbound Sanctum"]  = {Normal=180, Expert=185, Chaos=190, Calamity=195},
    ["Forsaken Limbo"]     = {Normal=200, Expert=205, Chaos=210, Calamity=215},
    ["Neon District"]      = {Normal=220, Expert=225, Chaos=230, Calamity=235},
}

local DifficultyOrder = { "Normal", "Expert", "Chaos", "Calamity" }

local function GetBestDungeonAndDifficulty(level)
    local bestDungeon = nil
    local bestDifficulty = nil

    for _, dungeon in ipairs(DungeonOrder) do
        for i = #DifficultyOrder, 1, -1 do
            local diff = DifficultyOrder[i]
            local req = DungeonReqs[dungeon][diff]

            if level >= req then
                bestDungeon = dungeon
                bestDifficulty = diff
                break
            end
        end
    end

    return bestDungeon, bestDifficulty
end

task.spawn(function()
    while task.wait(2) do
        if not AutoSwitchDungeon then continue end

        local data = LocalPlayer:FindFirstChild("data")
        local levelValue = data and data:FindFirstChild("level")
        if not levelValue then continue end

        local dungeonSettings = workspace:FindFirstChild("DungeonSettings")
        if not dungeonSettings then continue end

        local currentDungeon = dungeonSettings:FindFirstChild("SessionName")
        local currentDifficulty = dungeonSettings:FindFirstChild("Difficulty")
        if not currentDungeon or not currentDifficulty then continue end

        local level = levelValue.Value
        local bestDungeon, bestDifficulty = GetBestDungeonAndDifficulty(level)

        if not bestDungeon or not bestDifficulty then continue end

        local signature = bestDungeon .. "|" .. bestDifficulty
        if signature == LastSwitchSignature then continue end

        if currentDungeon.Value == bestDungeon and currentDifficulty.Value == bestDifficulty then
            LastSwitchSignature = signature
            continue
        end

        LastSwitchSignature = signature

        ReplicatedStorage:WaitForChild("SwitchDungeon"):FireServer({
            Map = bestDungeon,
            Calamity = (bestDifficulty == "Calamity"),
            Hardcore = false,
            NoHit = false,
            Difficulty = bestDifficulty,
            LevelRequirement = level,
            Tier = 0,
            Private = false,
            Easter = false
        })
    end
end)
-- =========================================================
-- WebHook
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local HttpService = game:GetService("HttpService")

local HttpRequest =
    (syn and syn.request)
    or (http and http.request)
    or http_request
    or request
    or (fluxus and fluxus.request)

if not HttpRequest then
    error("‚ùå Executor incompatible : HTTP requests non support√©es")
end

local allowedPlace = true
if game.PlaceId == 11872917490 then
    warn("üìå Webhook d√©sactiv√© dans cette map (11872917490) ‚Äî pas de CompletionScreen d√©tectable.")
    allowedPlace = false
end

local WebhookFile = "Webhook.txt"
local WebhookUrl = ""
if pcall(function() return readfile(WebhookFile) end) then
    WebhookUrl = readfile(WebhookFile)
end

local DiscordIdFile = "DiscordID.txt"
local DiscordID = ""
if pcall(function() return readfile(DiscordIdFile) end) then
    DiscordID = readfile(DiscordIdFile)
end

local Section = Tabs.Main:AddSection("Webhook")

Tabs.Main:AddInput("DiscordWebhook", {
    Title = "Discord Webhook",
    Description = "Paste your Discord webhook here",
    Default = WebhookUrl,
    Placeholder = "https://discord.com/api/webhooks/...",
    Numeric = false,
    Finished = false,
    Callback = function(value)
        WebhookUrl = value
        pcall(function() writefile(WebhookFile, value) end)
    end
})

Tabs.Main:AddInput("DiscordID", {
    Title = "Your Discord ID",
    Description = "Paste your Discord ID",
    Default = DiscordID,
    Placeholder = "123456789012345678",
    Numeric = false,
    Finished = false,
    Callback = function(value)
        DiscordID = value
        pcall(function() writefile(DiscordIdFile, value) end)
    end
})

local function postWebhook(payload)
    if WebhookUrl == "" then return end
    pcall(function()
        HttpRequest({
            Url = WebhookUrl,
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = HttpService:JSONEncode(payload)
        })
    end)
end

local function getDungeonName()
    local ds = workspace:FindFirstChild("DungeonSettings")
    local session = ds and ds:FindFirstChild("SessionName")
    return (session and session.Value ~= "" and session.Value) or "Unknown Dungeon"
end

local function formatNumber(num)
    num = tonumber(num)
    if not num then return "0" end

    if num >= 1e15 then
        return string.format("%.1fq", num / 1e15) -- Quadrillion
    elseif num >= 1e12 then
        return string.format("%.1fT", num / 1e12) -- Trillion
    elseif num >= 1e9 then
        return string.format("%.1fB", num / 1e9)  -- Billion
    elseif num >= 1e6 then
        return string.format("%.1fm", num / 1e6)  -- Million
    elseif num >= 1e3 then
        return string.format("%.1fk", num / 1e3)  -- Thousand
    else
        return tostring(num)
    end
end

local function sendDungeonWebhook(coins, expGained, elapsed, rewards)
    local data = LocalPlayer:FindFirstChild("data")
    if not data then return end

    local level = data.level.Value
    local exp = formatNumber(data.exp.Value)
    local expReq = formatNumber(data.expReq.Value)
    local dungeonName = getDungeonName()

    local rewardFields = {}
    local mentionPing = ""

    for _, r in ipairs(rewards) do
        table.insert(rewardFields, {
            name = r.name,
            value = "**Rarity:** " .. r.rarity,
            inline = true
        })

        if DiscordID ~= "" and (r.rarity:lower() == "legendary" or r.rarity:lower() == "heirloom") then
            mentionPing = "<@" .. DiscordID .. ">"
        end
    end

    if #rewardFields == 0 then
        table.insert(rewardFields, {
            name = "Rewards",
            value = "Aucune r√©compense",
            inline = false
        })
    end

    postWebhook({
        content = mentionPing,
        username = "Omega-Hub",
        embeds = {
            {
                title = "‚úÖ Round Completed!",
                color = 5763719,
                fields = {
                    {
                        name = "üë§ Account Information",
                        value =
                            "**Name:** Omega-Hub\n" ..
                            "**Current Level:** " .. level .. "\n" ..
                            "**Level Progression:** " .. exp .. " / " .. expReq,
                        inline = false
                    },
                    {
                        name = "üó∫Ô∏è Dungeon Stats",
                        value =
                            "**Name:** " .. dungeonName .. "\n" ..
                            "**Time:** " .. elapsed .. "\n" ..
                            "**Coins Gained:** " .. coins .. "\n" ..
                            "**EXP Gained:** " .. expGained,
                        inline = false
                    }
                }
            },
            {
                title = "üéÅ Rewards",
                color = 3447003,
                fields = rewardFields
            }
        },
        footer = { text = "Omega-Hub ‚Ä¢ " .. os.date("%d/%m/%Y %H:%M") }
    })
end
-- =========================================================
-- ALERT WEBHOOK (STOP / STUCK / FAIL)
local function sendAlertWebhook(reason, extra)
    if WebhookUrl == "" then return end

    postWebhook({
        username = "Omega-Hub",
        embeds = {
            {
                title = "‚ö†Ô∏è Auto Farm Stopped",
                color = 16753920, -- orange
                fields = {
                    {
                        name = "üë§ Player",
                        value = LocalPlayer.Name,
                        inline = true
                    },
                    {
                        name = "üó∫Ô∏è Dungeon",
                        value = getDungeonName(),
                        inline = true
                    },
                    {
                        name = "‚õî Reason",
                        value = reason,
                        inline = false
                    },
                    {
                        name = "üìå Details",
                        value = extra or "N/A",
                        inline = false
                    }
                },
                footer = {
                    text = "Omega-Hub ‚Ä¢ " .. os.date("%d/%m/%Y %H:%M")
                }
            }
        }
    })
end

_G.sendAlertWebhook = sendAlertWebhook

local function fetchCompletionData()
    local gui = LocalPlayer:FindFirstChild("PlayerGui")
    if not gui then return end

    local screen = gui:FindFirstChild("CompletionScreen")
    if not screen then return end

    local border = screen:FindFirstChild("CompletionBorder")
    if not border or not border.Visible then return end

    local main = border:FindFirstChild("CompletionMain")
    if not main then return end

    local rewardFrame = main:FindFirstChild("RewardFrame")
    if not rewardFrame then return end

    local lastCount, stableTime, start = 0, 0, tick()
    while tick() - start < 8 do
        local count = #rewardFrame:GetChildren()
        if count == lastCount then
            stableTime += 0.1
        else
            stableTime = 0
            lastCount = count
        end
        if stableTime >= 1 then break end
        task.wait(0.1)
    end

    local rewards = {}
    for _, frame in ipairs(rewardFrame:GetChildren()) do
        if frame:IsA("Frame") then
            local stats = frame:FindFirstChild("itemStats")
            local nameVal = stats and stats:FindFirstChild("itemName")
            if nameVal then
                table.insert(rewards, { rarity = frame.Name, name = nameVal.Value })
            end
        end
    end

    local coins = main:FindFirstChild("CoinsValue") and main.CoinsValue.Text or "0"
    local expGained = main:FindFirstChild("EXPValue") and main.EXPValue.Text or "0"
    local elapsed = main:FindFirstChild("ElapsedValue") and main.ElapsedValue.Text or "0"

    sendDungeonWebhook(coins, expGained, elapsed, rewards)
end

if allowedPlace then
    local function listenCompletion()
        local gui = LocalPlayer:WaitForChild("PlayerGui")
        local screen = gui:FindFirstChild("CompletionScreen")
        if not screen then return end
        local border = screen:FindFirstChild("CompletionBorder")
        if not border then return end

        border:GetPropertyChangedSignal("Visible"):Connect(function()
            if border.Visible then
                task.wait(0.3)
                fetchCompletionData()
            end
        end)
    end

    listenCompletion()
end
-- =========================================================
-- CONFIG
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)
SaveManager:LoadAutoloadConfig()
Window:SelectTab(1)
