local function LoadModule(url)
    local module
    repeat
        local success, result = pcall(function()
            return loadstring(game:HttpGet(url))()
        end)
        if success then
            module = result
        else
            warn("Module non charg√©, retry dans 1s : "..url)
            wait(1)
        end
    until module
    return module
end

local player = game.Players.LocalPlayer
repeat wait() until player and player.Character and player.Character:FindFirstChild("HumanoidRootPart")
--
if getgenv().ReinjectLoaded then return end
getgenv().ReinjectLoaded = true

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local ScriptURL = "https://raw.githubusercontent.com/Omeghub/devOnly/refs/heads/main/tes.tfabled"

local queue = queue_on_teleport 
           or (syn and syn.queue_on_teleport) 
           or (fluxus and fluxus.queue_on_teleport) 
           or queueonteleport

if not queue then
    return
end

local TeleportQueued = false

LocalPlayer.OnTeleport:Connect(function()
    if TeleportQueued then return end
    TeleportQueued = true

    queue([[
        repeat task.wait() until game:IsLoaded()
        task.wait(2)
        loadstring(game:HttpGet("]]..ScriptURL..[[", true))()
    ]])
end)
--=======================================================
-- UI
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/Omeghub/OmegaHubtest/refs/heads/main/UiSave"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/Omeghub/OmegaHubtest/refs/heads/main/Interface"))()

local Window = Fluent:CreateWindow({
   Title = "OmegaHub | Fabled-Legacy",
   TabWidth = 160,
   Size = UDim2.fromOffset(580, 460),
   Theme = "Dark",
   Acrylic = false,
   MinimizeKey = Enum.KeyCode.End
})

local Tabs = {
    Main = Window:AddTab({ Title = "Auto Farm", Icon = "swords" }),
    Tower = Window:AddTab({ Title = "Infinite Towers", Icon = "sword" }),
    Stats = Window:AddTab({ Title = "Stats", Icon = "trending-up" }),
    Sell = Window:AddTab({Title = "Sell", Icon = "layers" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}
-- ========================================================
-- AUTO FARM SYSTEM (AUTO START DUNGEON - FIX FINAL)
-- ========================================================

-- Toggle values
local AutoFarmValue = Instance.new("BoolValue")
AutoFarmValue.Value = false

local AutoSpellValue = Instance.new("BoolValue")
AutoSpellValue.Value = false

local EquipBestDone = false
local executedDungeons = {}
local DungeonStarted = false
local AutoStartDungeon = false

-- Dungeon scripts
local DungeonScripts = {
    ["Raided Village"] = "https://raw.githubusercontent.com/Omeghub/FabledlegacyDungeon/refs/heads/main/Afirstdungeon",
    ["Sunken Fortress"] = "https://raw.githubusercontent.com/Omeghub/FabledlegacyDungeon/refs/heads/main/Btwodungeon",
    ["Cursed Marshes"] = "https://raw.githubusercontent.com/Omeghub/FabledlegacyDungeon/refs/heads/main/Cthirddungeon",
   -- ["Ragnar√∂k's Descent"] = "https://raw.githubusercontent.com/Omeghub/FabledlegacyDungeon/refs/heads/main/Dfourdungeon",
   -- ["Thundering Peaks"] = "https://raw.githubusercontent.com/Omeghub/FabledlegacyDungeon/refs/heads/main/Efivedungeon",
   -- ["Fallen Paradise"] = "https://raw.githubusercontent.com/Omeghub/FabledlegacyDungeon/refs/heads/main/Fsixdungeon",
    ["Eternal Domain"] = "",
    ["Stardust Citadel"] = "",
    ["Ethereal Farlands"] = "",
    ["Hellbound Sanctum"] = "",
    ["Forsaken Limbo"] = "",
    --["Neon District"] = "https://raw.githubusercontent.com/Omeghub/FabledlegacyDungeon/refs/heads/main/ltwelfthdungeon",
}

-- Services
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local VirtualInputManager = game:GetService("VirtualInputManager")

-- ========================================================
-- VIRTUAL CLICK (TEXTBUTTON EXACT)
local function ClickStartDungeon()
    local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
    if not playerGui then return end

    local mainGui = playerGui:FindFirstChild("mainGui")
    if not mainGui then return end

    local startDungeon = mainGui:FindFirstChild("startDungeon")
    if not startDungeon then return end

    local button = startDungeon:FindFirstChild("TextButton")
    if not button then return end
    if not button.Visible or not button.Active then return end
    if DungeonStarted then return end

    -- Equip best AVANT start
    if not EquipBestDone then
        local equipBest = ReplicatedStorage:FindFirstChild("EquipBest")
        if equipBest then
            equipBest:FireServer()
        end
        EquipBestDone = true
    end

    -- Position √©cran du bouton
    local pos = button.AbsolutePosition
    local size = button.AbsoluteSize
    local x = pos.X + size.X / 2
    local y = pos.Y + size.Y / 2

    -- Click souris r√©el
    VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 0)
    task.wait(0.05)
    VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 0)

    DungeonStarted = true
    warn("[AUTO START] Click sur startDungeon.TextButton")
end

-- ========================================================
-- MAIN LOOP
task.spawn(function()
    while task.wait(1) do

        -- Load dungeon script
        local settings = Workspace:FindFirstChild("DungeonSettings")
        local session = settings and settings:FindFirstChild("SessionName")
        if session then
            local dungeonName = session.Value
            if not executedDungeons[dungeonName] then
                local url = DungeonScripts[dungeonName]
                if url then
                    local ok, err = pcall(function()
                        local fn = loadstring(game:HttpGet(url))()
                        fn(AutoFarmValue, AutoSpellValue)
                        executedDungeons[dungeonName] = true
                    end)
                    if not ok then
                        warn("Erreur dungeon:", err)
                    end
                end
            end
        end

        -- Auto start dungeon
        if AutoStartDungeon and not DungeonStarted then
            ClickStartDungeon()
        end

        -- Spawn companion
        if AutoFarmValue.Value and Workspace:FindFirstChild("CompanionPart") then
            local spawnComp = ReplicatedStorage:FindFirstChild("SpawnCompanion")
            if spawnComp then
                spawnComp:FireServer()
            end
        end
    end
end)

-- ========================================================
-- UI TOGGLES
Tabs.Main:AddToggle("AutoFarmTP", {
    Title = "Auto Farm TP",
    Default = false,
    Callback = function(v)
        AutoFarmValue.Value = v
        if not v then
            EquipBestDone = false
            DungeonStarted = false
        end
    end
})

Tabs.Main:AddToggle("AutoStartDungeon", {
    Title = "Auto Start Dungeon",
    Default = false,
    Callback = function(v)
        AutoStartDungeon = v
        if not v then
            DungeonStarted = false
        end
    end
})

Tabs.Main:AddToggle("AutoSpell", {
    Title = "Auto Spell Q / E / R",
    Default = false,
    Callback = function(v)
        AutoSpellValue.Value = v
    end
})

-- =========================================================
-- AUTO RETRY (FAIL + COMPLETION)
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

local AutoRetry = false
local Connections = {}

local function fireRetry(reason)
    if not AutoRetry then return end
    if _G.ForceReturnToLobby then return end

    local voteRemote = ReplicatedStorage:FindFirstChild("voteRemote")
    if voteRemote then
        warn("üîÅ Auto Retry triggered:", reason)
        voteRemote:FireServer("repeat")

        if _G.sendAlertWebhook then
            _G.sendAlertWebhook(
                "Auto Retry Dungeon Finish",
                reason
            )
        end
    end
end

local function SetupAutoRetry()
    if #Connections > 0 then return end

    local gui = LocalPlayer:WaitForChild("PlayerGui")
    local completionScreen = gui:WaitForChild("CompletionScreen")

    local failedFrame = completionScreen:WaitForChild("failedFrame")
    local completionBorder = completionScreen:WaitForChild("CompletionBorder")

    table.insert(Connections,
        failedFrame:GetPropertyChangedSignal("Visible"):Connect(function()
            if failedFrame.Visible then
                fireRetry("Dungeon failed")
            end
        end)
    )

    table.insert(Connections,
        completionBorder:GetPropertyChangedSignal("Visible"):Connect(function()
            if completionBorder.Visible then
                fireRetry("Dungeon completed")
            end
        end)
    )
end

local function StopAutoRetry()
    AutoRetry = false
    for _, c in ipairs(Connections) do
        pcall(function() c:Disconnect() end)
    end
    Connections = {}
end

Tabs.Main:AddToggle("AutoRetry", {
    Title = "Auto Retry (Fail + Win)",
    Default = false,
    Callback = function(v)
        AutoRetry = v
        if v then
            SetupAutoRetry()
        else
            StopAutoRetry()
        end
    end
})
-- =========================================================
-- AUTO SMART SWITCH DUNGEON

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer

local AutoSwitchDungeon = false
local LastSwitchSignature = ""

Tabs.Main:AddToggle("AutoSmartSwitch", {
    Title = "Auto Switch Dungeon (Smart)",
    Default = false,
    Callback = function(v)
        AutoSwitchDungeon = v
    end
})

local DungeonOrder = {
    "Raided Village",
    "Sunken Fortress",
    "Cursed Marshes",
    "Ragnar√∂k's Descent",
    "Thundering Peaks",
    "Fallen Paradise",
    "Eternal Domain",
    "Stardust Citadel",
    "Ethereal Farlands",
    "Hellbound Sanctum",
    "Forsaken Limbo",
    "Neon District"
}

local DungeonReqs = {
    ["Raided Village"]     = {Normal=1,   Expert=5,   Chaos=10,  Calamity=15},
    ["Sunken Fortress"]    = {Normal=20,  Expert=25,  Chaos=30,  Calamity=35},
    ["Cursed Marshes"]     = {Normal=40,  Expert=45,  Chaos=50,  Calamity=55},
    ["Ragnar√∂k's Descent"] = {Normal=60,  Expert=65,  Chaos=70,  Calamity=75},
    ["Thundering Peaks"]   = {Normal=80,  Expert=85,  Chaos=90,  Calamity=95},
    ["Fallen Paradise"]    = {Normal=100, Expert=105, Chaos=110, Calamity=115},
    ["Eternal Domain"]     = {Normal=120, Expert=125, Chaos=130, Calamity=135},
    ["Stardust Citadel"]   = {Normal=140, Expert=145, Chaos=150, Calamity=155},
    ["Ethereal Farlands"]  = {Normal=160, Expert=165, Chaos=170, Calamity=175},
    ["Hellbound Sanctum"]  = {Normal=180, Expert=185, Chaos=190, Calamity=195},
    ["Forsaken Limbo"]     = {Normal=200, Expert=205, Chaos=210, Calamity=215},
    ["Neon District"]      = {Normal=220, Expert=225, Chaos=230, Calamity=235},
}

local DifficultyOrder = { "Normal", "Expert", "Chaos", "Calamity" }

local function GetBestDungeonAndDifficulty(level)
    local bestDungeon = nil
    local bestDifficulty = nil

    for _, dungeon in ipairs(DungeonOrder) do
        for i = #DifficultyOrder, 1, -1 do
            local diff = DifficultyOrder[i]
            local req = DungeonReqs[dungeon][diff]

            if level >= req then
                bestDungeon = dungeon
                bestDifficulty = diff
                break
            end
        end
    end

    return bestDungeon, bestDifficulty
end

task.spawn(function()
    while task.wait(2) do
        if not AutoSwitchDungeon then continue end

        local data = LocalPlayer:FindFirstChild("data")
        local levelValue = data and data:FindFirstChild("level")
        if not levelValue then continue end

        local dungeonSettings = workspace:FindFirstChild("DungeonSettings")
        if not dungeonSettings then continue end

        local currentDungeon = dungeonSettings:FindFirstChild("SessionName")
        local currentDifficulty = dungeonSettings:FindFirstChild("Difficulty")
        if not currentDungeon or not currentDifficulty then continue end

        local level = levelValue.Value
        local bestDungeon, bestDifficulty = GetBestDungeonAndDifficulty(level)

        if not bestDungeon or not bestDifficulty then continue end

        local signature = bestDungeon .. "|" .. bestDifficulty
        if signature == LastSwitchSignature then continue end

        if currentDungeon.Value == bestDungeon and currentDifficulty.Value == bestDifficulty then
            LastSwitchSignature = signature
            continue
        end

        LastSwitchSignature = signature

        ReplicatedStorage:WaitForChild("SwitchDungeon"):FireServer({
            Map = bestDungeon,
            Calamity = (bestDifficulty == "Calamity"),
            Hardcore = false,
            NoHit = false,
            Difficulty = bestDifficulty,
            LevelRequirement = level,
            Tier = 0,
            Private = false,
            Easter = false
        })
    end
end)
-- =========================================================
-- WebHook
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local HttpService = game:GetService("HttpService")

local HttpRequest =
    (syn and syn.request)
    or (http and http.request)
    or http_request
    or request
    or (fluxus and fluxus.request)

if not HttpRequest then
    error("‚ùå Executor incompatible : HTTP requests non support√©es")
end

local allowedPlace = true
if game.PlaceId == 11872917490 then
    warn("üìå Webhook d√©sactiv√© dans cette map (11872917490) ‚Äî pas de CompletionScreen d√©tectable.")
    allowedPlace = false
end

local WebhookFile = "Webhook.txt"
local WebhookUrl = ""
if pcall(function() return readfile(WebhookFile) end) then
    WebhookUrl = readfile(WebhookFile)
end

local DiscordIdFile = "DiscordID.txt"
local DiscordID = ""
if pcall(function() return readfile(DiscordIdFile) end) then
    DiscordID = readfile(DiscordIdFile)
end

local Section = Tabs.Main:AddSection("Webhook")

Tabs.Main:AddInput("DiscordWebhook", {
    Title = "Discord Webhook",
    Description = "Paste your Discord webhook here",
    Default = WebhookUrl,
    Placeholder = "https://discord.com/api/webhooks/...",
    Numeric = false,
    Finished = false,
    Callback = function(value)
        WebhookUrl = value
        pcall(function() writefile(WebhookFile, value) end)
    end
})

Tabs.Main:AddInput("DiscordID", {
    Title = "Your Discord ID",
    Description = "Paste your Discord ID",
    Default = DiscordID,
    Placeholder = "123456789012345678",
    Numeric = false,
    Finished = false,
    Callback = function(value)
        DiscordID = value
        pcall(function() writefile(DiscordIdFile, value) end)
    end
})

local function postWebhook(payload)
    if WebhookUrl == "" then return end
    pcall(function()
        HttpRequest({
            Url = WebhookUrl,
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = HttpService:JSONEncode(payload)
        })
    end)
end

local function getDungeonName()
    local ds = workspace:FindFirstChild("DungeonSettings")
    local session = ds and ds:FindFirstChild("SessionName")
    return (session and session.Value ~= "" and session.Value) or "Unknown Dungeon"
end

local function formatNumber(num)
    num = tonumber(num)
    if not num then return "0" end

    if num >= 1e15 then
        return string.format("%.1fq", num / 1e15) -- Quadrillion
    elseif num >= 1e12 then
        return string.format("%.1fT", num / 1e12) -- Trillion
    elseif num >= 1e9 then
        return string.format("%.1fB", num / 1e9)  -- Billion
    elseif num >= 1e6 then
        return string.format("%.1fm", num / 1e6)  -- Million
    elseif num >= 1e3 then
        return string.format("%.1fk", num / 1e3)  -- Thousand
    else
        return tostring(num)
    end
end

local function sendDungeonWebhook(coins, expGained, elapsed, rewards)
    local data = LocalPlayer:FindFirstChild("data")
    if not data then return end

    local level = data.level.Value
    local exp = formatNumber(data.exp.Value)
    local expReq = formatNumber(data.expReq.Value)
    local dungeonName = getDungeonName()

    local rewardFields = {}
    local mentionPing = ""

    for _, r in ipairs(rewards) do
        table.insert(rewardFields, {
            name = r.name,
            value = "**Rarity:** " .. r.rarity,
            inline = true
        })

        if DiscordID ~= "" and (r.rarity:lower() == "legendary" or r.rarity:lower() == "heirloom") then
            mentionPing = "<@" .. DiscordID .. ">"
        end
    end

    if #rewardFields == 0 then
        table.insert(rewardFields, {
            name = "Rewards",
            value = "Aucune r√©compense",
            inline = false
        })
    end

    postWebhook({
        content = mentionPing,
        username = "Omega-Hub",
        embeds = {
            {
                title = "‚úÖ Round Completed!",
                color = 5763719,
                fields = {
                    {
                        name = "üë§ Account Information",
                        value =
                            "**Name:** Omega-Hub\n" ..
                            "**Current Level:** " .. level .. "\n" ..
                            "**Level Progression:** " .. exp .. " / " .. expReq,
                        inline = false
                    },
                    {
                        name = "üó∫Ô∏è Dungeon Stats",
                        value =
                            "**Name:** " .. dungeonName .. "\n" ..
                            "**Time:** " .. elapsed .. "\n" ..
                            "**Coins Gained:** " .. coins .. "\n" ..
                            "**EXP Gained:** " .. expGained,
                        inline = false
                    }
                }
            },
            {
                title = "üéÅ Rewards",
                color = 3447003,
                fields = rewardFields
            }
        },
        footer = { text = "Omega-Hub ‚Ä¢ " .. os.date("%d/%m/%Y %H:%M") }
    })
end
-- =========================================================
-- ALERT WEBHOOK (STOP / STUCK / FAIL)
local function sendAlertWebhook(reason, extra)
    if WebhookUrl == "" then return end

    postWebhook({
        username = "Omega-Hub",
        embeds = {
            {
                title = "‚ö†Ô∏è Auto Farm Stopped",
                color = 16753920, -- orange
                fields = {
                    {
                        name = "üë§ Player",
                        value = LocalPlayer.Name,
                        inline = true
                    },
                    {
                        name = "üó∫Ô∏è Dungeon",
                        value = getDungeonName(),
                        inline = true
                    },
                    {
                        name = "‚õî Reason",
                        value = reason,
                        inline = false
                    },
                    {
                        name = "üìå Details",
                        value = extra or "N/A",
                        inline = false
                    }
                },
                footer = {
                    text = "Omega-Hub ‚Ä¢ " .. os.date("%d/%m/%Y %H:%M")
                }
            }
        }
    })
end

_G.sendAlertWebhook = sendAlertWebhook

local function fetchCompletionData()
    local gui = LocalPlayer:FindFirstChild("PlayerGui")
    if not gui then return end

    local screen = gui:FindFirstChild("CompletionScreen")
    if not screen then return end

    local border = screen:FindFirstChild("CompletionBorder")
    if not border or not border.Visible then return end

    local main = border:FindFirstChild("CompletionMain")
    if not main then return end

    local rewardFrame = main:FindFirstChild("RewardFrame")
    if not rewardFrame then return end

    local lastCount, stableTime, start = 0, 0, tick()
    while tick() - start < 8 do
        local count = #rewardFrame:GetChildren()
        if count == lastCount then
            stableTime += 0.1
        else
            stableTime = 0
            lastCount = count
        end
        if stableTime >= 1 then break end
        task.wait(0.1)
    end

    local rewards = {}
    for _, frame in ipairs(rewardFrame:GetChildren()) do
        if frame:IsA("Frame") then
            local stats = frame:FindFirstChild("itemStats")
            local nameVal = stats and stats:FindFirstChild("itemName")
            if nameVal then
                table.insert(rewards, { rarity = frame.Name, name = nameVal.Value })
            end
        end
    end

    local coins = main:FindFirstChild("CoinsValue") and main.CoinsValue.Text or "0"
    local expGained = main:FindFirstChild("EXPValue") and main.EXPValue.Text or "0"
    local elapsed = main:FindFirstChild("ElapsedValue") and main.ElapsedValue.Text or "0"

    sendDungeonWebhook(coins, expGained, elapsed, rewards)
end

if allowedPlace then
    local function listenCompletion()
        local gui = LocalPlayer:WaitForChild("PlayerGui")
        local screen = gui:FindFirstChild("CompletionScreen")
        if not screen then return end
        local border = screen:FindFirstChild("CompletionBorder")
        if not border then return end

        border:GetPropertyChangedSignal("Visible"):Connect(function()
            if border.Visible then
                task.wait(0.3)
                fetchCompletionData()
            end
        end)
    end

    listenCompletion()
end
-- =========================================================
-- AUTO INFINITE TOWER
repeat task.wait() until game:IsLoaded()

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local Character, HRP
local AutoInfiniteTower = false

local UsePortal1 = true
local UsePortal2 = true
local UsePortal3 = false

local PromptDelay = 0.3
local PortalDelay = 0.25
local TreasureOffset = Vector3.new(0, 3, 0)

local function SetupCharacter(char)
    Character = char
    HRP = char:WaitForChild("HumanoidRootPart")
end

if LocalPlayer.Character then
    SetupCharacter(LocalPlayer.Character)
end

LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(1)
    SetupCharacter(char)
end)

Tabs.Tower:AddToggle("AutoInfiniteTower", {
    Title = "Auto Infinite Tower",
    Default = false,
    Callback = function(v)
        AutoInfiniteTower = v
    end
})

Tabs.Tower:AddToggle("Portal1", {
    Title = "Use Portal 1",
    Default = true,
    Callback = function(v)
        UsePortal1 = v
    end
})

Tabs.Tower:AddToggle("Portal2", {
    Title = "Use Portal 2",
    Default = true,
    Callback = function(v)
        UsePortal2 = v
    end
})

Tabs.Tower:AddToggle("Portal3", {
    Title = "Use Portal 3",
    Default = false,
    Callback = function(v)
        UsePortal3 = v
    end
})

local function HandlePortals()
    local gui = LocalPlayer:FindFirstChild("PlayerGui")
    if not gui then return end

    local portalsGui = gui:FindFirstChild("Portals")
    if not portalsGui then return end

    local mainGroup = portalsGui:FindFirstChild("MainGroup")
    if not mainGroup or not mainGroup.Visible then return end

    if UsePortal1 then
        ReplicatedStorage:WaitForChild("DisplayPortals"):FireServer(1)
        task.wait(PortalDelay)
    end

    if UsePortal2 then
        ReplicatedStorage:WaitForChild("DisplayPortals"):FireServer(2)
        task.wait(PortalDelay)
    end

    if UsePortal3 then
        ReplicatedStorage:WaitForChild("DisplayPortals"):FireServer(3)
        task.wait(PortalDelay)
    end
end

local function TpToTreasure()
    if not HRP then return end

    local treasure = workspace:FindFirstChild("Treasure")
    if not treasure then return end

    local ringPart = treasure:FindFirstChild("ringRewardsPart")
    if not ringPart then return end

    HRP.CFrame = ringPart.CFrame + TreasureOffset
end

local function FarmTowerRewards()
    local treasure = workspace:FindFirstChild("Treasure")
    if not treasure then return end

    local ringPart = treasure:FindFirstChild("ringRewardsPart")
    if not ringPart then return end

    local promptFolder = ringPart:FindFirstChild("prompt")
    if not promptFolder then return end

    local prompt = promptFolder:FindFirstChildOfClass("ProximityPrompt")
    if not prompt or not prompt.Enabled then return end

    TpToTreasure()
    task.wait(PromptDelay)

    fireproximityprompt(prompt)
end

task.spawn(function()
    while task.wait(0.3) do
        if not AutoInfiniteTower then continue end

        HandlePortals()
        FarmTowerRewards()
    end
end)
-- =========================================================
-- AUTO STATS
local AutoPhysical = false
local AutoSpellStat = false
local AutoHealth = false

local function AddPoint(stat)
    ReplicatedStorage.addSkillPoints:FireServer(stat, 1)
end

task.spawn(function()
    while task.wait(0.2) do
        
        if not AutoPhysical and not AutoSpellStat and not AutoHealth then 
            continue 
        end
        
        local freeSP = LocalPlayer.data.freeSP.Value
        if freeSP <= 0 then
            task.wait(1)
        else
            if AutoPhysical then AddPoint("physical") end
            if AutoSpellStat then AddPoint("spell") end
            if AutoHealth then AddPoint("health") end
        end
    end
end)


Tabs.Stats:AddToggle("AutoPhysical", {
    Title = "Auto Physical",
    Default = false,
    Callback = function(v) AutoPhysical = v end
})

Tabs.Stats:AddToggle("AutoSpellStat", {
    Title = "Auto Spell",
    Default = false,
    Callback = function(v) AutoSpellStat = v end
})

Tabs.Stats:AddToggle("AutoHealth", {
    Title = "Auto Health",
    Default = false,
    Callback = function(v) AutoHealth = v end
})
-- =========================================================
-- AUTO SELL + AUTO RETURN + AUTO DUNGEON (SAFE)
repeat task.wait() until game:IsLoaded()

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

_G.ForceReturnToLobby = _G.ForceReturnToLobby or false

local AutoSell = false
local SellPlaceId = 11872917490 -- lobby

local OrderedRarities = { "common", "uncommon", "rare", "epic", "legendary", "heirloom" }
local SellRarities = {}
for _, r in ipairs(OrderedRarities) do
    SellRarities[r] = false
end

Tabs.Sell:AddToggle("AutoSellToggle", {
    Title = "Auto Sell + Dungeon",
    Default = false,
    Callback = function(v)
        AutoSell = v
    end
})

for _, rarity in ipairs(OrderedRarities) do
    Tabs.Sell:AddToggle(rarity, {
        Title = rarity:sub(1,1):upper()..rarity:sub(2),
        Default = false,
        Callback = function(v)
            SellRarities[rarity] = v
        end
    })
end

local Dungeons = {
    ["Raided Village"]      = { Normal=1,   Expert=5,   Chaos=10,  Calamity=15 },
    ["Sunken Fortress"]     = { Normal=20,  Expert=25,  Chaos=30,  Calamity=35 },
    ["Cursed Marshes"]      = { Normal=40,  Expert=45,  Chaos=50,  Calamity=55 },
    ["Ragnar√∂k's Descent"]  = { Normal=60,  Expert=65,  Chaos=70,  Calamity=75 },
    ["Thundering Peaks"]    = { Normal=80,  Expert=85,  Chaos=90,  Calamity=95 },
    ["Fallen Paradise"]     = { Normal=100, Expert=105, Chaos=110, Calamity=115 },
    ["Eternal Domain"]      = { Normal=120, Expert=125, Chaos=130, Calamity=135 },
    ["Stardust Citadel"]    = { Normal=140, Expert=145, Chaos=150, Calamity=155 },
    ["Ethereal Farlands"]   = { Normal=160, Expert=165, Chaos=170, Calamity=175 },
    ["Hellbound Sanctum"]   = { Normal=180, Expert=185, Chaos=190, Calamity=195 },
    ["Forsaken Limbo"]      = { Normal=200, Expert=205, Chaos=210, Calamity=215 },
    ["Neon District"]       = { Normal=220, Expert=225, Chaos=230, Calamity=235 },
}

local DifficultyOrder = { "Calamity", "Chaos", "Expert", "Normal" }

local function InventoryIsFull()
    local gui = LocalPlayer.PlayerGui
    local inv = gui:FindFirstChild("Inventory")
    if not inv then return false end

    local limitLabel = inv.Inventory:FindFirstChild("Limit")
    if not limitLabel then return false end

    local used, max = limitLabel.Text:match("(%d+)%s*/%s*(%d+)")
    if not used or not max then return false end

    return tonumber(used) >= tonumber(max)
end

local function GetItemsToSell()
    local inventory = LocalPlayer.PlayerGui.Inventory.Inventory.RightSide.ScrollingFrame
    if not inventory then return nil end

    local items = {
        armors={}, rings={}, helmets={}, legs={},
        spells={}, sigils={}, weapons={}
    }

    local found = false

    for _, frame in ipairs(inventory:GetChildren()) do
        if frame:IsA("Frame") and frame:FindFirstChild("itemStats") then
            local s = frame.itemStats
            if s.itemType and s.itemRarity and s.GUID then
                local rarity = s.itemRarity.Value:lower()
                if SellRarities[rarity] and items[s.itemType.Value] then
                    table.insert(items[s.itemType.Value], s.GUID.Value)
                    found = true
                end
            end
        end
    end

    return found and items or nil
end

local function ReturnToLobby()
    _G.ForceReturnToLobby = true
    ReplicatedStorage.DungeonFail:FireServer()
    task.wait(0.5)
    ReplicatedStorage.voteRemote:FireServer("return")
end

local function SellItems()
    local items = GetItemsToSell()
    if not items then return end

    ReplicatedStorage.EquipBest:FireServer()
    task.wait(8)
    ReplicatedStorage.sellItems:InvokeServer(items)
    task.wait(1)
    ReplicatedStorage.EquipBest:FireServer()
end

local function GetBestDungeon()
    local level = LocalPlayer.data.level.Value
    local bestMap, bestDiff, bestReq = nil, nil, 0

    for map, diffs in pairs(Dungeons) do
        for _, diff in ipairs(DifficultyOrder) do
            local req = diffs[diff]
            if req and level >= req and req > bestReq then
                bestMap, bestDiff, bestReq = map, diff, req
            end
        end
    end

    return bestMap, bestDiff, bestReq
end

local function CreateAndStartDungeon()
    local map, diff, req = GetBestDungeon()
    if not map then return end

    local args = {{
        Map = map,
        Difficulty = diff,
        LevelRequirement = req,
        Calamity = false,
        Hardcore = false,
        NoHit = false,
        Tier = 0,
        Private = false,
        Easter = false
    }}

    ReplicatedStorage.CreateLobby:InvokeServer(unpack(args))
    task.wait(1)
    ReplicatedStorage.StartLobby:FireServer()
end

task.spawn(function()
    while task.wait(1) do
        if not AutoSell then continue end

        if InventoryIsFull() and game.PlaceId ~= SellPlaceId then
            ReturnToLobby()
        end

        if game.PlaceId == SellPlaceId then
            SellItems()
            task.wait(2)
            CreateAndStartDungeon()
            _G.ForceReturnToLobby = false
        end
    end
end)

-- =========================================================
-- CONFIG
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)
SaveManager:LoadAutoloadConfig()
Window:SelectTab(1)
